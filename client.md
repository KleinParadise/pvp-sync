### UDP帧同步方案优点
1. **高一致性。** 如果每一帧的输入都同步了，在同样的上下文中，计算得出的结果应该也是同步的。
2. **低流量消耗。** 除了帧同步，其他方案（状态同步）想做到一致性，需要同步非常大量的数据，无论对移动网络还是固定网络都是不合适的。
3. **服务逻辑简化。** 采用帧同步的方案，服务器只要做简单的帧同步，不需要关心太多的业务细节。有利于客户端功能的扩展和服务器的稳定和性能。
4. **反作弊。** 客户端只需要在适当的时机上报校验数据给服务器，服务器对两个客户端上报的数据进行对比，就可以快速识别是否有人作弊。

### 为何选择UDP而非TCP
1. 弱网络环境
2. 实时性要求  

通过一个测试app,在WiFi和4g环境下,分别采用UDP和TCP连接同一个服务器，对比发现在弱网环境下，UDP的RTT几乎不受影响。而TCP得RTT波动较大,受丢包率影响明显。


### 基于UDP的FSP协议栈
由于UDP具有不可靠性，所以在UDP的基础上实现一个自定义的协议栈:FSP 即FrameSyncProtocol  
FSP的基本原理就是仿照TCP的ACK/SEQ重传机制，实现了传输的可靠性，同时还采用了冗余换速度的方式，保证了传输的速率。在帧同步方案中一举两得。

### 帧同步技术原理
客户端A的操作A1与客户端B的操作B1封装成OperateCmd数据发送PVP服务器。PVP服务器每66ms产生一个逻辑帧，在该帧所在时间段内收到A1和B1后，生成一个Frame数据块，在该帧时间结束时，将Frame发送给客户端A和客户端B。Frame数据块内有该帧的帧号。客户端A和B收到Frame数据后，便知道该帧内，客户端A和B都做了什么操作。然后根据收到的操作A1和B1进行游戏表现，最终呈现给玩家A和B的结果是一致的。从而实现客户端A和B的数据同步。

### FSP协议栈原理
发送者维持一个发送队列，对每一次发送进行编号。每一次发送时，会将待发送的数据写入队列。然后将队列里的**数据+编号**发送给接收者。  
接收者收到数据后，会将该编号回送给发送者以确认。发送者收到确认编号后，会将该编号对应的数据包从队列中删除，否则该数据仍保存在发送队列中。  
下次发送时，会有新的数据进入队列。然后将队列中的数据+最新编号发送给接收者。以此往复。  

第1次发送，在发送队列里只有Data1,于是将Data1和编号1(sep = 1)发送给接收者。收到确认编号1(ack = 1)后，将Data1从队列中删除。  
第4到7次发送，由于从第4次发送开始就没有收到确认编号，于是队列中包含了Data4和Data7。第7次发送后，收到确认编号6，于是将Data4至Data6从队列中删除。  
第8次发送，队列中包含Data7和Data8。发送后收到确认编号8，从而将Data7和Data8从队列中删除。
以上关键点是，发送者未收到确认编号，并不一直等待，而是会继续下一次发送。  


结合图1：  
如果发送者是服务器，则会每隔66ms会将一个Frame数据写入发送队列，然后将该队列的所有Frame数据一起发送给客户端。  
如果发送者是客户端，则会在玩家有操作时，将玩家的每一个OperateCmd数据写入发送队列，然后将该队列里的所有的OperateCmd数据一起发送给服务器。如果发送队列不为空，则每隔99ms重复发送。如果发送队列为空，则不在发送。直到玩家下一次操作。  
由于服务器和客户端既是发送者，又是接收者。则服务器和客户端的每一次发送，除了会带上该次发送的编号，还会带上对对方发送编号的确认。
